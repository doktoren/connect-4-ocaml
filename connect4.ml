(*
Not yet needed.

module BitLover = struct
  let bitcount n =
	  let m0 = 0x5555555555555555
	  and m1 = 0x3333333333333333
	  and m2 = 0x0f0f0f0f0f0f0f0f
	  and m3 = 0x00ff00ff00ff00ff
	  and m4 = 0x0000ffff0000ffff
	  and m5 = 0x00000000ffffffff in
	  let n = (n land m0) + ((n lsr 1) land m0) in
	  let n = (n land m1) + ((n lsr 2) land m1) in
	  let n = (n land m2) + ((n lsr 4) land m2) in
	  let n = (n land m3) + ((n lsr 8) land m3) in
	  let n = (n land m4) + ((n lsr 16) land m4) in
	  (n land m5) + (n lsr 32)

  let test () =
	  let f x = Printf.printf "bitcount(%d) = %d\n" x (bitcount x) in
	  f 42;
	  f 1;
	  f 0x7fffffffffffffff;
	  f 256;
	  f (0x1+0x4+0x10+0x100+0x10000+0x100000000)
end
*)

module type BoardI = sig
  type position = int (* 0 to 41 *)
  type position_pattern = int
  type column = int

  type t = { board: int; filter: int; moves: position list}

  val patterns : position_pattern list array
  val list_moves : t -> column list
  val make_move : t -> column -> t
  val undo_move : t -> t
  val init : unit -> t
  val print : t -> unit
  val game_over : t -> bool
end

module Board : BoardI = struct

  (* The bit mask values of the board positions *)
  let f0,f1,f2,f3,f4,f5,f6 = 1 lsl 35, 1 lsl 36, 1 lsl 37, 1 lsl 38, 1 lsl 39, 1 lsl 40, 1 lsl 41
  let e0,e1,e2,e3,e4,e5,e6 = 1 lsl 28, 1 lsl 29, 1 lsl 30, 1 lsl 31, 1 lsl 32, 1 lsl 33, 1 lsl 34
  let d0,d1,d2,d3,d4,d5,d6 = 1 lsl 21, 1 lsl 22, 1 lsl 23, 1 lsl 24, 1 lsl 25, 1 lsl 26, 1 lsl 27
  let c0,c1,c2,c3,c4,c5,c6 = 1 lsl 14, 1 lsl 15, 1 lsl 16, 1 lsl 17, 1 lsl 18, 1 lsl 19, 1 lsl 20
  let b0,b1,b2,b3,b4,b5,b6 = 1 lsl  7, 1 lsl  8, 1 lsl  9, 1 lsl 10, 1 lsl 11, 1 lsl 12, 1 lsl 13
  let a0,a1,a2,a3,a4,a5,a6 = 1 lsl  0, 1 lsl  1, 1 lsl  2, 1 lsl  3, 1 lsl  4, 1 lsl  5, 1 lsl  6
  
  (* Auto generated by the function generate_patterns *)
  let patterns = [|
  (* a0 *) [ a0 lor b1 lor c2 lor d3; a0 lor b0 lor c0 lor d0; a0 lor a1 lor a2 lor a3 ];
  (* a1 *) [ a1 lor b2 lor c3 lor d4; a1 lor b1 lor c1 lor d1; a1 lor a2 lor a3 lor a4; a0 lor a1 lor a2 lor a3 ];
  (* a2 *) [ a2 lor b3 lor c4 lor d5; a2 lor b2 lor c2 lor d2; a2 lor a3 lor a4 lor a5; a1 lor a2 lor a3 lor a4; a0 lor a1 lor a2 lor a3 ];
  (* a3 *) [ a3 lor b4 lor c5 lor d6; d0 lor c1 lor b2 lor a3; a3 lor b3 lor c3 lor d3; a3 lor a4 lor a5 lor a6; a2 lor a3 lor a4 lor a5; a1 lor a2 lor a3 lor a4; a0 lor a1 lor a2 lor a3 ];
  (* a4 *) [ d1 lor c2 lor b3 lor a4; a4 lor b4 lor c4 lor d4; a3 lor a4 lor a5 lor a6; a2 lor a3 lor a4 lor a5; a1 lor a2 lor a3 lor a4 ];
  (* a5 *) [ d2 lor c3 lor b4 lor a5; a5 lor b5 lor c5 lor d5; a3 lor a4 lor a5 lor a6; a2 lor a3 lor a4 lor a5 ];
  (* a6 *) [ d3 lor c4 lor b5 lor a6; a6 lor b6 lor c6 lor d6; a3 lor a4 lor a5 lor a6 ];
  (* b0 *) [ b0 lor c1 lor d2 lor e3; b0 lor c0 lor d0 lor e0; a0 lor b0 lor c0 lor d0; b0 lor b1 lor b2 lor b3 ];
  (* b1 *) [ b1 lor c2 lor d3 lor e4; a0 lor b1 lor c2 lor d3; b1 lor c1 lor d1 lor e1; a1 lor b1 lor c1 lor d1; b1 lor b2 lor b3 lor b4; b0 lor b1 lor b2 lor b3 ];
  (* b2 *) [ b2 lor c3 lor d4 lor e5; a1 lor b2 lor c3 lor d4; d0 lor c1 lor b2 lor a3; b2 lor c2 lor d2 lor e2; a2 lor b2 lor c2 lor d2; b2 lor b3 lor b4 lor b5; b1 lor b2 lor b3 lor b4; b0 lor b1 lor b2 lor b3 ];
  (* b3 *) [ b3 lor c4 lor d5 lor e6; a2 lor b3 lor c4 lor d5; d1 lor c2 lor b3 lor a4; e0 lor d1 lor c2 lor b3; b3 lor c3 lor d3 lor e3; a3 lor b3 lor c3 lor d3; b3 lor b4 lor b5 lor b6; b2 lor b3 lor b4 lor b5; b1 lor b2 lor b3 lor b4; b0 lor b1 lor b2 lor b3 ];
  (* b4 *) [ a3 lor b4 lor c5 lor d6; d2 lor c3 lor b4 lor a5; e1 lor d2 lor c3 lor b4; b4 lor c4 lor d4 lor e4; a4 lor b4 lor c4 lor d4; b3 lor b4 lor b5 lor b6; b2 lor b3 lor b4 lor b5; b1 lor b2 lor b3 lor b4 ];
  (* b5 *) [ d3 lor c4 lor b5 lor a6; e2 lor d3 lor c4 lor b5; b5 lor c5 lor d5 lor e5; a5 lor b5 lor c5 lor d5; b3 lor b4 lor b5 lor b6; b2 lor b3 lor b4 lor b5 ];
  (* b6 *) [ e3 lor d4 lor c5 lor b6; b6 lor c6 lor d6 lor e6; a6 lor b6 lor c6 lor d6; b3 lor b4 lor b5 lor b6 ];
  (* c0 *) [ c0 lor d1 lor e2 lor f3; c0 lor d0 lor e0 lor f0; b0 lor c0 lor d0 lor e0; a0 lor b0 lor c0 lor d0; c0 lor c1 lor c2 lor c3 ];
  (* c1 *) [ c1 lor d2 lor e3 lor f4; b0 lor c1 lor d2 lor e3; d0 lor c1 lor b2 lor a3; c1 lor d1 lor e1 lor f1; b1 lor c1 lor d1 lor e1; a1 lor b1 lor c1 lor d1; c1 lor c2 lor c3 lor c4; c0 lor c1 lor c2 lor c3 ];
  (* c2 *) [ c2 lor d3 lor e4 lor f5; b1 lor c2 lor d3 lor e4; a0 lor b1 lor c2 lor d3; d1 lor c2 lor b3 lor a4; e0 lor d1 lor c2 lor b3; c2 lor d2 lor e2 lor f2; b2 lor c2 lor d2 lor e2; a2 lor b2 lor c2 lor d2; c2 lor c3 lor c4 lor c5; c1 lor c2 lor c3 lor c4; c0 lor c1 lor c2 lor c3 ];
  (* c3 *) [ c3 lor d4 lor e5 lor f6; b2 lor c3 lor d4 lor e5; a1 lor b2 lor c3 lor d4; d2 lor c3 lor b4 lor a5; e1 lor d2 lor c3 lor b4; f0 lor e1 lor d2 lor c3; c3 lor d3 lor e3 lor f3; b3 lor c3 lor d3 lor e3; a3 lor b3 lor c3 lor d3; c3 lor c4 lor c5 lor c6; c2 lor c3 lor c4 lor c5; c1 lor c2 lor c3 lor c4; c0 lor c1 lor c2 lor c3 ];
  (* c4 *) [ b3 lor c4 lor d5 lor e6; a2 lor b3 lor c4 lor d5; d3 lor c4 lor b5 lor a6; e2 lor d3 lor c4 lor b5; f1 lor e2 lor d3 lor c4; c4 lor d4 lor e4 lor f4; b4 lor c4 lor d4 lor e4; a4 lor b4 lor c4 lor d4; c3 lor c4 lor c5 lor c6; c2 lor c3 lor c4 lor c5; c1 lor c2 lor c3 lor c4 ];
  (* c5 *) [ a3 lor b4 lor c5 lor d6; e3 lor d4 lor c5 lor b6; f2 lor e3 lor d4 lor c5; c5 lor d5 lor e5 lor f5; b5 lor c5 lor d5 lor e5; a5 lor b5 lor c5 lor d5; c3 lor c4 lor c5 lor c6; c2 lor c3 lor c4 lor c5 ];
  (* c6 *) [ f3 lor e4 lor d5 lor c6; c6 lor d6 lor e6 lor f6; b6 lor c6 lor d6 lor e6; a6 lor b6 lor c6 lor d6; c3 lor c4 lor c5 lor c6 ];
  (* d0 *) [ d0 lor c1 lor b2 lor a3; c0 lor d0 lor e0 lor f0; b0 lor c0 lor d0 lor e0; a0 lor b0 lor c0 lor d0; d0 lor d1 lor d2 lor d3 ];
  (* d1 *) [ c0 lor d1 lor e2 lor f3; d1 lor c2 lor b3 lor a4; e0 lor d1 lor c2 lor b3; c1 lor d1 lor e1 lor f1; b1 lor c1 lor d1 lor e1; a1 lor b1 lor c1 lor d1; d1 lor d2 lor d3 lor d4; d0 lor d1 lor d2 lor d3 ];
  (* d2 *) [ c1 lor d2 lor e3 lor f4; b0 lor c1 lor d2 lor e3; d2 lor c3 lor b4 lor a5; e1 lor d2 lor c3 lor b4; f0 lor e1 lor d2 lor c3; c2 lor d2 lor e2 lor f2; b2 lor c2 lor d2 lor e2; a2 lor b2 lor c2 lor d2; d2 lor d3 lor d4 lor d5; d1 lor d2 lor d3 lor d4; d0 lor d1 lor d2 lor d3 ];
  (* d3 *) [ c2 lor d3 lor e4 lor f5; b1 lor c2 lor d3 lor e4; a0 lor b1 lor c2 lor d3; d3 lor c4 lor b5 lor a6; e2 lor d3 lor c4 lor b5; f1 lor e2 lor d3 lor c4; c3 lor d3 lor e3 lor f3; b3 lor c3 lor d3 lor e3; a3 lor b3 lor c3 lor d3; d3 lor d4 lor d5 lor d6; d2 lor d3 lor d4 lor d5; d1 lor d2 lor d3 lor d4; d0 lor d1 lor d2 lor d3 ];
  (* d4 *) [ c3 lor d4 lor e5 lor f6; b2 lor c3 lor d4 lor e5; a1 lor b2 lor c3 lor d4; e3 lor d4 lor c5 lor b6; f2 lor e3 lor d4 lor c5; c4 lor d4 lor e4 lor f4; b4 lor c4 lor d4 lor e4; a4 lor b4 lor c4 lor d4; d3 lor d4 lor d5 lor d6; d2 lor d3 lor d4 lor d5; d1 lor d2 lor d3 lor d4 ];
  (* d5 *) [ b3 lor c4 lor d5 lor e6; a2 lor b3 lor c4 lor d5; f3 lor e4 lor d5 lor c6; c5 lor d5 lor e5 lor f5; b5 lor c5 lor d5 lor e5; a5 lor b5 lor c5 lor d5; d3 lor d4 lor d5 lor d6; d2 lor d3 lor d4 lor d5 ];
  (* d6 *) [ a3 lor b4 lor c5 lor d6; c6 lor d6 lor e6 lor f6; b6 lor c6 lor d6 lor e6; a6 lor b6 lor c6 lor d6; d3 lor d4 lor d5 lor d6 ];
  (* e0 *) [ e0 lor d1 lor c2 lor b3; c0 lor d0 lor e0 lor f0; b0 lor c0 lor d0 lor e0; e0 lor e1 lor e2 lor e3 ];
  (* e1 *) [ e1 lor d2 lor c3 lor b4; f0 lor e1 lor d2 lor c3; c1 lor d1 lor e1 lor f1; b1 lor c1 lor d1 lor e1; e1 lor e2 lor e3 lor e4; e0 lor e1 lor e2 lor e3 ];
  (* e2 *) [ c0 lor d1 lor e2 lor f3; e2 lor d3 lor c4 lor b5; f1 lor e2 lor d3 lor c4; c2 lor d2 lor e2 lor f2; b2 lor c2 lor d2 lor e2; e2 lor e3 lor e4 lor e5; e1 lor e2 lor e3 lor e4; e0 lor e1 lor e2 lor e3 ];
  (* e3 *) [ c1 lor d2 lor e3 lor f4; b0 lor c1 lor d2 lor e3; e3 lor d4 lor c5 lor b6; f2 lor e3 lor d4 lor c5; c3 lor d3 lor e3 lor f3; b3 lor c3 lor d3 lor e3; e3 lor e4 lor e5 lor e6; e2 lor e3 lor e4 lor e5; e1 lor e2 lor e3 lor e4; e0 lor e1 lor e2 lor e3 ];
  (* e4 *) [ c2 lor d3 lor e4 lor f5; b1 lor c2 lor d3 lor e4; f3 lor e4 lor d5 lor c6; c4 lor d4 lor e4 lor f4; b4 lor c4 lor d4 lor e4; e3 lor e4 lor e5 lor e6; e2 lor e3 lor e4 lor e5; e1 lor e2 lor e3 lor e4 ];
  (* e5 *) [ c3 lor d4 lor e5 lor f6; b2 lor c3 lor d4 lor e5; c5 lor d5 lor e5 lor f5; b5 lor c5 lor d5 lor e5; e3 lor e4 lor e5 lor e6; e2 lor e3 lor e4 lor e5 ];
  (* e6 *) [ b3 lor c4 lor d5 lor e6; c6 lor d6 lor e6 lor f6; b6 lor c6 lor d6 lor e6; e3 lor e4 lor e5 lor e6 ];
  (* f0 *) [ f0 lor e1 lor d2 lor c3; c0 lor d0 lor e0 lor f0; f0 lor f1 lor f2 lor f3 ];
  (* f1 *) [ f1 lor e2 lor d3 lor c4; c1 lor d1 lor e1 lor f1; f1 lor f2 lor f3 lor f4; f0 lor f1 lor f2 lor f3 ];
  (* f2 *) [ f2 lor e3 lor d4 lor c5; c2 lor d2 lor e2 lor f2; f2 lor f3 lor f4 lor f5; f1 lor f2 lor f3 lor f4; f0 lor f1 lor f2 lor f3 ];
  (* f3 *) [ c0 lor d1 lor e2 lor f3; f3 lor e4 lor d5 lor c6; c3 lor d3 lor e3 lor f3; f3 lor f4 lor f5 lor f6; f2 lor f3 lor f4 lor f5; f1 lor f2 lor f3 lor f4; f0 lor f1 lor f2 lor f3 ];
  (* f4 *) [ c1 lor d2 lor e3 lor f4; c4 lor d4 lor e4 lor f4; f3 lor f4 lor f5 lor f6; f2 lor f3 lor f4 lor f5; f1 lor f2 lor f3 lor f4 ];
  (* f5 *) [ c2 lor d3 lor e4 lor f5; c5 lor d5 lor e5 lor f5; f3 lor f4 lor f5 lor f6; f2 lor f3 lor f4 lor f5 ];
  (* f6 *) [ c3 lor d4 lor e5 lor f6; c6 lor d6 lor e6 lor f6; f3 lor f4 lor f5 lor f6 ];
  |]

  type position = int
  type position_pattern = int
  type column = int

  type t = { board: int; filter: int; moves: position list}

  let list_moves { board; _} =
    List.filter (fun column -> (board land (1 lsl (42 + column))) == 0) [0; 1; 2; 3; 4; 5; 6]

  let insert_position { filter; _} column =
    let rec inner position =
      match filter land (1 lsl position) with
        | 0 -> position
        | _ -> inner (position + 7)
    in
    inner column

  let make_move ({ board; filter; moves } as t) column =
    let pos = insert_position t column in
    assert (pos < 42);
    let filter = filter lxor (1 lsl pos) in
    let board = board lxor (129 lsl pos) lxor filter in
    let moves = pos :: moves in
    { board; filter; moves }

  let undo_move { board; filter; moves } =
    let pos, moves = List.hd moves, List.tl moves in
    let board = board lxor (129 lsl pos) lxor filter in
    let filter = filter lxor (1 lsl pos) in
    { board; filter; moves }

  let init () =
    { board = a0 lor a1 lor a2 lor a3 lor a4 lor a5 lor a6;
      filter = 0;
      moves = [];
    }

  let print { board; filter; moves } =
    Printf.printf "|1|2|3|4|5|6|7|\n";
    Printf.printf "|-|-|-|-|-|-|-|\n";
    let board = match List.length moves land 1 with
      | 0 -> board
      | _ -> board lxor filter
    in
    for row = 5 downto 0 do
      for column = 0 to 6 do
        let pos = 1 lsl (7*row + column) in
        let str = match pos land filter with
          | 0 ->
            "."
          | _ ->
            match pos land board with
              | 0 -> "X"
              | _ -> "O"
        in
        Printf.printf " %s" str
      done;
      Printf.printf "\n"
    done

  let game_over { board; filter; moves; _ } =
    match moves with
      | [] ->
        false
      | last_move :: moves ->
        let board = board land filter in
        List.exists (fun pattern -> board land pattern = pattern) patterns.(last_move)

end

module type EngineI = sig
  val request_move : Board.t -> Board.column
end

module Engine : EngineI = struct
  type t =
    { board: Board.t;
      player_value: int;
      pos_values: int array;
    }

  let pos_values = Array.map (fun l -> 10 * List.length l) Board.patterns

  let make_move {board; player_value; pos_values} column =
    let board = Board.make_move board column in
    let player_value = match board with
      | { Board.moves = move :: moves; _ } -> -(player_value + pos_values.(move))
      | _ -> assert false
    in 
    { board; player_value; pos_values }

  (* Returns the value of the board for the player to move *)
  let min_max ({board; _} as t) ply =
    let rec min_max ({ board; player_value; pos_values } as t) ply =
      match Board.game_over board, ply with
        | true, _ ->
          (* Game over - this is bad! The more it can be delayed, the better *)
          -1000000 - ply
        | _, 0 ->
          player_value
	      | _, ply ->
	        let move_values = List.map (fun column -> min_max (make_move t column) (ply-1)) (Board.list_moves board) in
          (* Use the move that gives the other player the lowest value, then negate it to get this players value *)
	        -(List.fold_left min max_int move_values)
    in
    let move_values = List.map (fun column -> column, min_max (make_move t column) (ply-1)) (Board.list_moves board) in
    (* Use move that gives opponent player lowest value *)
    let move, value = List.fold_left (fun (acc_move, acc_value) (move, value) -> match acc_value < value with
        | true -> (acc_move, acc_value)
        | false -> (move, value)
      ) (-2, max_int) move_values
    in
    move

  let request_move board =
    let pos_values = Array.map (fun v -> v + Random.int 15) pos_values in
    let player_value = 0 in
    let ply = 7 in
    min_max { board; pos_values; player_value } ply

end

module UI = struct

  let rec request_action message allowed_actions =
    Printf.printf "%s\n%!" message;
    let line = input_line stdin in
    try
      List.find (fun action -> action = line) allowed_actions
    with Not_found ->
      Printf.printf "Invalid input: %s\n%!" line;
      request_action message allowed_actions

  let rec interact ({Board.moves; _} as b) =
    Printf.printf "\n";
    Board.print b;
    Printf.printf "\n";
    let action = match (List.length moves, Board.game_over b) with
      | _, true ->
        request_action "Game over! u: undo move, n: new game, q: quit." ["u"; "n"; "q"]
      | 42, _ ->
        request_action "A draw! u: undo move, n: new game, q: quit." ["u"; "n"; "q"]
      | 0, _ ->
        let moves = List.map string_of_int (List.map ((+) 1) (Board.list_moves b)) in
        request_action ((String.concat "," moves) ^ ": make move, c: computer move, q: quit") (moves @ ["c"; "q"])
      | _, _ ->
        let moves = List.map string_of_int (List.map ((+) 1) (Board.list_moves b)) in
        request_action ((String.concat "," moves) ^ ": make move, u: undo move, c: computer move, n: new game, q: quit") (moves @ ["c"; "u"; "n"; "q"])
    in
    match action with
      | "q" -> Printf.printf "Exiting...\n"; exit 0
      | "n" -> interact (Board.init ())
      | "u" -> interact (Board.undo_move b)
      | "c" -> interact (Board.make_move b (let column = Engine.request_move b in Printf.printf "Computer plays column %d\n" (column+1); column))
      | human_move -> interact (Board.make_move b (int_of_string human_move - 1))

  let run () = interact (Board.init ())

end

let generate_patterns () =
  let directions = [(1,0); (0,1); (1,-1); (1, 1)] in
  let pos_name (column, row) = Printf.sprintf "%c%d" (char_of_int (row + 97)) column in
  Printf.printf "  let patterns = [|\n";
  for row = 0 to 5 do
    for column = 0 to 6 do
      let valid_pos (column, row) = 0<=column && column<=6 && 0<=row && row<=5 in
      let for_line acc (d_column, d_row) =
        let for_line_and_offset acc offset =
          let pos_on_line offset = column + offset*d_column, row + offset*d_row in
          let valid_start = valid_pos (pos_on_line offset) in
          let valid_end = valid_pos (pos_on_line (3+offset)) in
          match valid_start && valid_end with
            | true ->
              let positions = List.map pos_on_line [offset; offset+1; offset+2; offset+3] in
              (String.concat " lor " (List.map pos_name positions)) :: acc
            | false ->
              acc
        in
        List.fold_left for_line_and_offset acc [-3; -2; -1; 0]
      in
      let patterns = String.concat "; " (List.fold_left for_line [] directions) in
      Printf.printf "  (* %s *) [ %s ];\n" (pos_name (column, row)) patterns
    done
  done;
  Printf.printf "  |]\n"

let _ =
  UI.run ()

